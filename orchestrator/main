use std::io::{self, Write};

fn main() {
    print!("Industry name: ");
    io::stdout().flush().unwrap();
    let mut industry = String::new();
    io::stdin().read_line(&mut industry).unwrap();
    let industry = industry.trim();

    let kernel = generate_kernel(industry);
    std::fs::create_dir_all(format!("templates/lex{}/src", industry.to_lowercase())).unwrap();
    std::fs::write(
        format!("templates/lex{}/src/lib.rs", industry.to_lowercase()),
        kernel,
    )
    .unwrap();
    // copy integration stubs
    std::fs::write(
        format!("templates/lex{}/src/adapter.rs", industry.to_lowercase()),
        include_str!("adapter.rs.stub"),
    ).unwrap();
    std::fs::write(
        format!("templates/lex{}/src/cache.rs", industry.to_lowercase()),
        include_str!("cache.rs.stub"),
    ).unwrap();

    println!("✅ Lex{} kernel created", industry.to_lowercase());
}

fn generate_kernel(industry: &str) -> String {
    let splitter_addr = "0x1234…abCd";          // << CHANGE ONLY HERE ONCE
    let patent_byte = (industry.len() % 256) as u8;

    format!(
        r#"[package]
name = "lex{industry}"
version = "0.1.0"
edition = "2021"

[dependencies]
sha3 = {{ version = "0.10", default-features = false }}
serde_json = {{ version = "1.0", default-features = false, optional = true }}
csv = {{ version = "1.3", default-features = false, optional = true }}
bincode = {{ version = "1.3", default-features = false, optional = true }}

[features]
default = []
legacy-adapter = ["dep:serde_json", "dep:csv"]
air-gap = ["dep:bincode"]

[lib]
name = "lex{industry}"
path = "src/lib.rs"

{KERNEL_SRC}
"#,
        industry = industry,
        KERNEL_SRC = kernel_source_code(industry, splitter_addr, patent_byte)
    )
}

fn kernel_source_code(industry: &str, splitter_addr: &str, patent_byte: u8) -> String {
    format!(
        r#"#![no_std]
#![forbid(unsafe_code)]
//! Lex{industry} kernel – copyright 2025 Lex Libertatum Trust, A.T.W.W., Trustee
//! Per-Decision Royalty Licence (see LICENCE-RDR)

extern crate alloc;
use alloc::vec::Vec;
use sha3::{{Digest, Sha3_256}};
use core::sync::atomic::{{AtomicU64, Ordering}};

pub const LICENCE_RDR: &[u8] = b"Lex-Libertatum-Trust-RDR-2025-Per-Decision-Royalty";
pub const PATENT_TAG: [u8; 6] = *b"UPAT{patent_byte:02x}\x00";
pub const SPLITTER: &str = "{splitter_addr}";

static CALL_COUNT: AtomicU64 = AtomicU64::new(0);

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum Decision {{ Certified, Rejected }}

pub struct Report {{
    pub id: [u8; 32],
    pub score: u8,
    pub nanos: u64,
    pub metadata: Vec<u8>,
}}

pub struct Certificate {{
    pub decision: Decision,
    pub id: [u8; 32],
    pub score: u8,
    pub nanos: u64,
    pub patent_tag: [u8; 6],
    pub call_seq: u64,
}}

impl Certificate {{
    pub fn hash(&self) -> [u8; 32] {{
        let mut h = Sha3_256::new();
        h.update(&self.id);
        h.update([self.score]);
        h.update(self.nanos.to_be_bytes());
        h.update(&(self.decision as u8).to_be_bytes());
        h.update(&self.patent_tag);
        h.update(self.call_seq.to_be_bytes());
        h.finalize().into()
    }}
}}

pub fn decide(report: &Report) -> (Decision, Certificate) {{
    let seq = CALL_COUNT.fetch_add(1, Ordering::Relaxed);
    let decision = if report.score >= 80 {{ Decision::Certified }} else {{ Decision::Rejected }};
    let cert = Certificate {{
        decision,
        id: report.id,
        score: report.score,
        nanos: report.nanos,
        patent_tag: PATENT_TAG,
        call_seq: seq,
    }};
    (decision, cert)
}}

#[cfg(feature = "legacy-adapter")]
pub mod adapter;

#[cfg(feature = "air-gap")]
pub mod cache;
"#
    )
}
